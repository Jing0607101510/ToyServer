## 定时器容器使用什么数据结构？

- 链表，排序链表？
- 时间轮
  - 以上两种方案都是使用固定频率调用心搏函数，获取当前时间，并且依次检测到期的定时器，执行指定的回调函数。
- 时间堆？ 初步是这个
  - 将所有定时器中超时时间最小的一个定时器的超时值作为心搏间隔，一旦心搏函数被调用，超时时间最小的定时器必然到期，就可以在tick函数中处理该定时器。然后再次从剩余的定时器中找出超时时间最小的一个，并将这段最小时间设置为下一次心搏间隔。
  - 堆中的元素的超时时间被更新后，怎么调整这个定时器在堆中的位置？
    - ?先删除，再插入。？
  - 如果需要删除堆中不是最小的定时器，如何操作？
    - 设置回调函数为NULL，延迟销毁。

## one thread one loop模式下，定时器如何通知各个线程回收空闲的连接？

- 是否每一个thread，一个定时器容器？
- 游双的书中，因为定时器容器只被主线程所使用，所以不需要加锁。那么在one thread one loop的情况下，是否需要互斥？



## 定时器具体是怎么实现的？

- 如果在one thread one loop的模式下，是不是不使用时钟信号来定时通知要处理定时器的事件？
  1. 是否是设置epoll_wait的超时时间？
  2. 是否是整个进程一个时钟信号，一个时钟信号处理函数向各个wakeup fd中发送消息？
  3. 只有一个线程相应信号处理吗？
  4. one thread one loop中每个线程一个定时器容器，还是整个进程只有一个定时器？
     1. 每一个线程都有一个定时器容器
  5. 使用优先队列实现的定时器容器，更新操作是怎么样的？



## 定时器封装的定时对象，包括什么内容？

- 超时时间：相对时间/绝对时间
- 任务的回调函数，以及需要传入的参数。
- 是否重启定时器。





# 定时器容器需要实现的操作

- 定时器集合中增加、删除、修改和遍历



