# 项目目标

- 熟悉C++11的开发习惯
- 锻炼变量命名规则
- 掌握http服务器开发过程及其各个模块的开发





# 技术点

1. 设计模式：单例模式，使用静态局部变量、双检查锁的懒汉模式。
2. 同步和异步日志，异步使用日志队列和线程。并且使用互斥锁让工作线程互斥访问日志队列。加锁时不直接加锁，而是使用RAII机制。





# 遇到的问题和解决方法







# 玩转开源项目

- 熟悉用到的技术点
- 运行起来
- 阅读源码调试并调试（分模块）
- 改东西，加自己的功能和模块。





# 修改的地方

- 半同步半反应堆改为 **半同步半异步** one thread one loop？接收连接是在主线程中进行还是在工作线程中进行？
- 定时器改为 **时间堆**，保存的是指针
- 异步日志使用 **双缓冲**，不限制大小长度？使用什么容器？
  - 异步日志需要专门的日志线程写日志
- 只有一个的类 使用 **单例模式**
- 用户名，密码不直接保存明文，保存 **hash**
- 使用**C++11**的锁和条件变量，**智能指针**， **RAII**，锁之类的是否需要继续封装？
- 使用 **mysql** + **redis** 应用
- 各个线程的loop中循环条件为 true，在循环体中增加是否 **退出判断**
- 模仿**jsp解析html页面**
- 使用**cookie**
- 增加是否以**守护方式（服务）运行或者前台**运行
- 容器封装为**线程安全的容器**
- 定时函数由alarm转换为 **setitimer()**? 怎么使用？



# 注意事项

- 类成员变量的命名规范
  - public成员m_varName, private变量使用m_varName_
  - 函数funcName 动名词
- 类中分配了资源（堆中内存），记得析构或者uninit。
- 类的构造函数执行常规的设置，init函数执行特定的配置。
- 单例模式使用static变量
- 信号处理函数并不处理逻辑，而是将收到信号的消息通知给主程序，让主程序处理。
- 各种级别的日志使用宏定义
- 定时事件到来，关闭超时套接字（连接）的操作延迟，在循环完epoll的结果之后处理。
- 资源谁申请，谁负责释放。





# 几个模块

- 总模块 
- 日志模块 **完成**
- 线程池
- 连接池
- 配置类 **完成**
- 定时器
- 定时器容器（时间堆）
- 封装了定时器、fd、以及addr的类

- 一些用到的函数 工具类
- 请求类（对应http_conn）
- 



# 疑问

- one thread one loop中新连接由谁接收，怎么通知工作线程？
- one thread one loop中定时事件由谁通知（主线程）？
- connfd设置为LT的话，读和写具体应该怎么实现
- 多线程中信号处理的问题
  - 系统会将这个信号投递到进程号最小的那个可以处理这个信号的线程中去处理。
  - 所有的线程里，同一个信号在任何线程里对该信号的处理一定相同
  - 每个线程都有自己的信号屏蔽字,但是信号的处理是进程中所有的线程共享的
- 日志队列有最大长度，如果日志的个数超过了这个数量怎么处理？是使用**条件变量还是信号量**？
  - **信号量**是有一个**值（状态的**），而条件变量是没有的
  - 如果请求队列长度没有限制，那么条件变量或者信号量都是可以的
- 异步日志和同步日志怎么 代码怎么区分编写？
- 多进程或者多线程读写同一个文件需要加锁吗？
  - 一个问题是，先产生的日志后写入，影响不大
  - 另一个问题是，可能因为多线程写同一个文件，造成内容混合。
    - 在类Unix系统上，同一个进程内对同一个FILE*的操作是线程安全的。
- 信号处理函数和主程序之间通信的fd应该设置为什么触发模式？
  - 可水平，可边缘
- 当超过过期时间，或者需要close套接字时，http_conn和clientdata如何更新？项目中在超时的时候，似乎只是回收了fd，没有释放new出来的timer。
- one thread one loop中，每一个线程怎么存放类似http_conn和clientdata？
- 记录当前连接的用户数的变量m_user_count，需要锁来保护吗？也就是说，是否存在多个线程能同事访问或者修改这个变量？
- 用户级的读缓冲区和写缓冲区，如果数据超过这个缓冲区的大小怎么办？例如动态生成的内容很多，超过了缓冲区？m_read_idx如何何时复位？怎么避免一次性读取数据的时候把下一个请求也读取了？如何避免处理请求后将m_read_idx复位导致下一个请求的数据丢失？
- 如何使用标准库中的优先队列实现定时器堆。要删除的话怎么删除？要更新过期时间怎么更新？
- 双缓冲区怎么使用？和实现？
- client_data结构体含有timer指针，当这个timer到期时，怎么回收这个timer，并且关闭client_data的fd并且置timer指针为NULL
  - client_data结构题包含timer指针作为成员，并且timer类中成员包括了client_data指针，作为回调函数的参数
- 模板类的头文件和源文件需要分开写么？
- epoll遇到错误事件时，会触发EPOLLHUP或者EPOLLERR，同时EPOLLIN和EPOLLOUT事件有也被触发。
  - 所以在条件语句上，使用if-else if-else这种语句，而不是if-if-if这种语句。
- HTTP1.1默认长连接如何处理？
- 双缓冲是如何实现的？怎么通知日志线程处理（日志线程怎么知道应该处理了）？
  - 通知日志线程两个途径：1.超过指定的时间了。2.前端缓冲区满了。
- C++11的condition的notify是唤醒所有阻塞的线程，还是其中一个线程？
  - notify_one:没有线程等待，则什么都不做。如果有多个线程等待，则选择其中一个，具体选择哪一个则不确定
  - notify_all:唤醒所有
- 异步日志系统，将日志写入到日志队列中，如果需要关闭系统，那么日志队列中的日志怎么处理？在有设置is_running的标志下，直接根据这个标志退出，就会导致日志队列中的未写入文件的日志丢失，如何处理？
- 在多线程中使用std中的容器，我们知道这些容器不是线程安全的。我们知道要向容器中增减元素需要加锁，那么读取这个容器的大小需要加锁吗？
  - 最好用锁，多线程读写使用锁。
- 如何实现对数据库连接池中的空闲线程进行动态释放？





# 项目中出现的与语言、技术等相关的问题

- 在日志系统中设计一个线程安全的日志队列，封装std中的list。读取这个list的大小需要加锁吗？读写锁，读为什么加锁？
  - 因为写操作可能分成若干个CPU指令，如果不加锁，那么在这个期间读，读到中间结果。
- 什么时候使用std::move; 传入的右值引用是怎么使用的。传入的右值像普通变量一样使用吗
  - 左值和右值：左值，可以被复制；右值：不可被复制。
  - std::move将左值变为右值。
- std::bind(&A::func, 参数)是什么意思，绑定参数？
  - 可以绑定成员函数的参数。
- 出现：terminate called without an active exception
  - 由于主线程退出，导致子线程异常退出。（在对等线程为joinable时，主线程退出，子线程也退出）
  - 那么在对等线程为detach时，会怎么样？由于主线程退出时调用了_exit，所以导致整个进程退出了。
- C++中的单例模式，如果使用的是双检查锁使用静态成员指针变量。那么什么时候释放这个静态成员指针变量所指向的内存（静态成员变量的生命周期？）。谁来执行delete这个静态成员指针变量所指向的内存？
  - 静态成员变量的生命周期和程序的声明周期一致。
  - 所以单例模式中用new分配的内存得到的指针，赋值给静态成员指针变量时，不需要delete，由系统在程序结束时回收。
  - 单例模式不需要手动去释放资源。因为它只实例化一个对象，不会在运行期产生内存泄漏。程序结束时，操作系统会自动释放进程占有的全部资源，包括内存资源。
- 单例模式下，构造函数是private的，析构函数呢？
  - 如果想要析构静态成员变量所指向的堆内存单元，这个类可以暴露一个析构的接口。
- 关于智能指针shared_ptr和unique_ptr的用法，最终是析构对象的？只能传入new创建的对象的指针吗？
  - 只能用new在堆中分配内存的指针，初始化智能指针。
- C++11中thread作为类的成员？thread能赋值？赋值后是什么？
  - thread能作为成员。









# 关于日志系统

## 功能需求

- 尽量每条日志占一行，这样很容易用awk、sed、grep等命令行工具快速联机分析日志；
- 时间戳精确到微妙；
- 始终使用GMT时区(Z)；
- 打印线程id，便于分析多线程程序的时序，也可以检测死锁；
- 打印日志级别；
- 打印源文件名和行号。