# 数据库连接池

数据库的连接看成是一个对象，存放在容器中

- 单例模式，这里使用双检查锁实现单例模式
- 使用list作为连接池，存放MySQL*
- 连接池最大大小动态变化，为设定的参数大小，运行期间支持扩缩容   
  - 由一个管理线程周期性检查是否需要扩缩容
- 使用信号量？还是使用条件变量？这里类似于生产者消费者模式。
  - 有限缓冲区的，使用信号量
  - 无限缓冲区，使用条件变量搭配锁
- 由于连接池会被多个线程共享，所以需要锁 mtx
- 还有数据库的连接信息：
  1. 用户名
  2. 密码
  3. 数据库主机地址
  4. 数据库端口
  5. 数据库名
- 思路：数据库的连接当作一个对象添加进list队列中，在连接池创建的时候就建立好队列，并添加自定义大小的连接对象，连接对象用智能指针来管理（现代c++中不应该出现delete语句），避免类似内存泄漏等内存问题，智能指针上用lambda表达式注册了delete删除函数来释放连接资源，及时归还，（其中用了std::move来转移list中的对象所有权到函数里的临时智能指针对象，当离开作用域时，自动释放。
- 需求
  - 初始时先建立一些连接
  - 当连接被全部使用，还没有达到最大数量时，创建新的连接，放进连接池中。
  - 如果连接被全部使用，并且达到最大数量，则等待别的连接释放（这里需要使用信号量？）
  - 空闲时，定时在连接池中释放空闲的连接。
- 动态扩缩连接池的方案？
  - 连接池中创建一个管理线程，每隔一段时间（sleep），判断是否需要扩缩连接池。每隔20秒扫描一次。
- 怎么确定扩缩的时机条件 和 扩缩的大小？
  - 需要获取阻塞等待的任务数？使用信号量的sem_getvalue(sem_t * sem)函数获取正在阻塞等待的线程数。
  - 参考线程池的动态扩容缩容。
- sem信号量需不需要支持try_wait，或者阻塞等待一定的时间后返回？是否可以在确定没有连接的情况下就返回。或者等待一定时间。否则太多需要数据库连接的请求时，造成阻塞严重？
- 单例模式的类
  - 创建了对象还需要初始化（可能）
- 销毁连接池的时候，还有一些连接还没归还，怎么处理？
  - 非running的时候，才能销毁。
  - 并且在running的情况下，某些操作才能进行。
  - 使用信号量，阻塞等待所有的连接都归还。
- 遇到问题：为什么sem在wait之后阻塞，sem的值还是0
  - 如果一个或多个进程或线程被阻塞，等待用sem_wait（3）锁定信号量，POSIX.1-2001允许sval中返回的值有两种可能：返回0；或者一个负数，其绝对值是sem_wait（3）中当前阻塞的进程和线程数的计数。Linux采用前一种行为



# 数据库连接池中连接的获取 

- 使用RAII机制，设计一个类，封装在连接池中获取连接即析构时释放连接。
- 该类析构时，将数据库连接释放回连接池中。



