# 数据库连接池

数据库的连接看成是一个对象，存放在容器中

- 单例模式，这里使用双检查锁实现单例模式
- 使用list作为连接池，存放MySQL*
- 连接池最大大小动态变化，为设定的参数大小，运行期间支持扩缩容   
  - 由一个管理线程周期性检查是否需要扩缩容
- 使用信号量？还是使用条件变量？这里类似于生产者消费者模式。
  - 有限缓冲区的，使用信号量
  - 无限缓冲区，使用条件变量搭配锁
- 由于连接池会被多个线程共享，所以需要锁 mtx
- 还有数据库的连接信息：
  1. 用户名
  2. 密码
  3. 数据库主机地址
  4. 数据库端口
  5. 数据库名
- 思路：数据库的连接当作一个对象添加进list队列中，在连接池创建的时候就建立好队列，并添加自定义大小的连接对象，连接对象用智能指针来管理（现代c++中不应该出现delete语句），避免类似内存泄漏等内存问题，智能指针上用lambda表达式注册了delete删除函数来释放连接资源，及时归还，（其中用了std::move来转移list中的对象所有权到函数里的临时智能指针对象，当离开作用域时，自动释放。
- 需求
  - 初始时先建立一些连接
  - 当连接被全部使用，还没有达到最大数量时，创建新的连接，放进连接池中。
  - 如果连接被全部使用，并且达到最大数量，则等待别的连接释放（这里需要使用信号量？）
  - 空闲时，定时在连接池中释放空闲的连接。
- 动态扩缩连接池的方案？
  - 连接池中创建一个管理线程，每隔一段时间（sleep），判断是否需要扩缩连接池。
- 怎么确定扩缩的时机条件 和 扩缩的大小？
  - 需要获取阻塞等待的任务数？使用信号量的sem_getvalue(sem_t * sem)函数获取正在阻塞等待的线程数。
  - 参考线程池的动态扩容缩容。



# 数据库连接池中连接的获取 

- 使用RAII机制，设计一个类，封装在连接池中获取连接即析构时释放连接。
- 该类析构时，将数据库连接释放回连接池中。